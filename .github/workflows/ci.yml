name: CI/CD

on:
  push:
    branches: [ main, master ]
    tags:
      - 'v*'
  pull_request:
    branches: [ main, master ]
  workflow_dispatch:

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  build:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        if: github.event_name != 'pull_request'
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=sha

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: ${{ github.event_name != 'pull_request' }}
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  lint:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install flake8

      - name: Lint with flake8
        run: |
          flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics
          flake8 . --count --exit-zero --max-complexity=10 --max-line-length=127 --statistics

  deploy:
    runs-on: ubuntu-latest
    needs: build
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master' || github.event_name == 'workflow_dispatch'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up SSH
        run: |
          mkdir -p ~/.ssh
          # Write the key, ensuring proper formatting
          echo "${{ secrets.SSH_PRIVATE_KEY }}" | tr -d '\r' > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          # Start ssh-agent
          eval "$(ssh-agent -s)"
          # Add the key to the agent
          ssh-add ~/.ssh/deploy_key
          # Verify key was added
          ssh-add -l

      - name: Add server to known hosts
        run: |
          ssh-keyscan -H ${{ secrets.SERVER_HOST }} >> ~/.ssh/known_hosts

      - name: Test SSH connection
        run: |
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} "echo 'SSH connection successful'"

      - name: Setup database
        env:
          SERVER_HOST: ${{ secrets.SERVER_HOST }}
          SERVER_USER: ${{ secrets.SERVER_USER }}
          SERVER_PATH: ${{ secrets.SERVER_PATH }}
          DB_HOST: ${{ secrets.DB_HOST || 'postgres' }}
          DB_PORT: ${{ secrets.DB_PORT || '5432' }}
          DB_NAME: ${{ secrets.DB_NAME || 'receipty_bot' }}
          DB_USER: ${{ secrets.DB_USER || 'postgres' }}
          DB_PASSWORD: ${{ secrets.DB_PASSWORD || 'postgres' }}
        run: |
          # Create project directory if it doesn't exist
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} "mkdir -p ${{ secrets.SERVER_PATH }}"
          
          # Copy files to server (needed for docker-compose and init_db.py)
          scp -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no -r * ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }}:${{ secrets.SERVER_PATH }}/
          
          # Setup database on server
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} << EOF
            cd ${{ secrets.SERVER_PATH }}
            
            # Stop and remove old containers if they exist
            docker compose down || true
            
            # Start PostgreSQL container first
            echo "Starting PostgreSQL container..."
            docker compose up -d postgres
            
            # Wait for PostgreSQL to be ready
            echo "Waiting for PostgreSQL to be ready..."
            timeout=60
            counter=0
            while ! docker compose exec -T postgres pg_isready -U "$DB_USER" > /dev/null 2>&1; do
              if [ \$counter -ge \$timeout ]; then
                echo "PostgreSQL failed to start within \$timeout seconds"
                exit 1
              fi
              sleep 2
              counter=\$((counter + 2))
            done
            echo "PostgreSQL is ready!"
            
            # Check if database exists, create if not
            echo "Checking database..."
            # Connect to default 'postgres' database to check if target database exists
            DB_EXISTS=\$(docker compose exec -T postgres psql -U "$DB_USER" -d postgres -lqt | cut -d \| -f 1 | grep -w "$DB_NAME" | wc -l)
            
            if [ "\$DB_EXISTS" -eq 0 ]; then
              echo "Database '$DB_NAME' does not exist. Creating..."
              docker compose exec -T postgres psql -U "$DB_USER" -d postgres -c "CREATE DATABASE $DB_NAME;"
              echo "Database '$DB_NAME' created successfully!"
            else
              echo "Database '$DB_NAME' already exists."
            fi
            
            # Check if tables exist (check for 'user' and 'products' tables)
            echo "Checking if database is initialized..."
            # Check for 'user' table (quoted because it's a reserved word)
            USER_TABLE_EXISTS=\$(docker compose exec -T postgres psql -U "$DB_USER" -d "$DB_NAME" -tAc "SELECT COUNT(*) FROM information_schema.tables WHERE table_schema='public' AND table_name='user';" 2>/dev/null | tr -d '[:space:]' || echo "0")
            # Check for 'products' table
            PRODUCTS_TABLE_EXISTS=\$(docker compose exec -T postgres psql -U "$DB_USER" -d "$DB_NAME" -tAc "SELECT COUNT(*) FROM information_schema.tables WHERE table_schema='public' AND table_name='products';" 2>/dev/null | tr -d '[:space:]' || echo "0")
            
            echo "User table exists: \$USER_TABLE_EXISTS, Products table exists: \$PRODUCTS_TABLE_EXISTS"
            
            if [ "\$USER_TABLE_EXISTS" -eq "0" ] || [ "\$PRODUCTS_TABLE_EXISTS" -eq "0" ]; then
              echo "Database tables not found or incomplete. Initializing..."
              docker compose run --rm receipty-bot python init_db.py
              echo "Database initialized!"
            else
              echo "Database tables already exist. Skipping initialization."
            fi
          EOF

      - name: Deploy to server
        env:
          SERVER_HOST: ${{ secrets.SERVER_HOST }}
          SERVER_USER: ${{ secrets.SERVER_USER }}
          SERVER_PATH: ${{ secrets.SERVER_PATH }}
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          GOOGLE_SHEETS_SPREADSHEET_ID: ${{ secrets.GOOGLE_SHEETS_SPREADSHEET_ID }}
          GOOGLE_SHEETS_TAB_NAME: ${{ secrets.GOOGLE_SHEETS_TAB_NAME }}
          DB_HOST: ${{ secrets.DB_HOST || 'postgres' }}
          DB_PORT: ${{ secrets.DB_PORT || '5432' }}
          DB_NAME: ${{ secrets.DB_NAME || 'receipty_bot' }}
          DB_USER: ${{ secrets.DB_USER || 'postgres' }}
          DB_PASSWORD: ${{ secrets.DB_PASSWORD || 'postgres' }}
        run: |
          # Deploy bot container
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} << EOF
            cd ${{ secrets.SERVER_PATH }}
            
            # Stop and remove old bot container
            echo "Stopping old bot container..."
            docker compose stop receipty-bot || true
            docker compose rm -f receipty-bot || true
            
            # Build new image with latest code
            echo "Building new bot image..."
            docker compose build receipty-bot
            
            # Start bot container with new image
            echo "Starting bot container with new image..."
            docker compose up -d receipty-bot
            
            echo "Deployment complete!"
            docker compose ps
            echo "Bot logs (last 20 lines):"
            docker compose logs --tail=20 receipty-bot
          EOF
      
      - name: Cleanup SSH key
        if: always()
        run: |
          rm -f ~/.ssh/deploy_key

